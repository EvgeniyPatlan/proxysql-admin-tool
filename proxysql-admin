#!/bin/bash
# This script will assist with configuring ProxySQL (currently only Percona XtraDB cluster in combination with ProxySQL is supported)
# Version 1.0
###############################################################################################

# This program is copyright 2016-2018 Percona LLC and/or its affiliates.
#
# THIS PROGRAM IS PROVIDED "AS IS" AND WITHOUT ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation, version 2 or later
#
# You should have received a copy of the GNU General Public License version 2
# along with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA.

#-------------------------------------------------------------------------------
#
# Step 1 : Bash internal configuration
#

set -o nounset    # no undefined variables
set -o pipefail   # internal pipe failures cause an exit

#bash prompt internal configuration
declare BD=""
declare NBD=""
declare RED=""
declare NRED=""

# Test if stdout and stderr are open to a terminal
if [[ -t 1 ]]; then
  BD=$(tput bold)
  NBD=$(tput sgr0)
fi
if [[ -t 2 ]]; then
  RED=$(tput setaf 1)
  NRED=$(tput sgr0)
fi

#-------------------------------------------------------------------------------
#
# Step 2 : Global variables
#

#
# Script parameters/constants
#
readonly    PROXYSQL_ADMIN_VERSION="2.0.3"
declare  -i DEBUG=0

# default timeout is 10 seconds
declare  -i TIMEOUT=10

#
# Global variables used by the script
#
declare    CONFIG_FILE="/etc/proxysql-admin.cnf"
declare    PROXYSQL_DATADIR=""

declare    PROXYSQL_USERNAME=""
declare    PROXYSQL_PASSWORD=""
declare    PROXYSQL_PORT=""
declare    PROXYSQL_HOSTNAME=""

declare    CLUSTER_USERNAME=""
declare    CLUSTER_PASSWORD=""
declare    CLUSTER_HOSTNAME=""
declare    CLUSTER_PORT=""

declare    WRITE_NODE=""

declare    MODE="singlewrite"
declare -i NODE_CHECK_INTERVAL=-1

declare -i WRITER_HOSTGROUP_ID=-1
declare -i READER_HOSTGROUP_ID=-1
declare -i BACKUP_WRITER_HOSTGROUP_ID=-1
declare -i OFFLINE_HOSTGROUP_ID=-1

declare -i QUICK_DEMO=0
declare -i ENABLE=0
declare -i DISABLE=0
declare -i ADDUSER=0
declare -i SYNCUSERS=0
declare -i SYNCMULTICLUSTERUSERS=0
declare -i UPDATE_CLUSTER=0

declare -i USE_EXISTING_MONITOR_PASSWORD=0
declare -i WITH_CLUSTER_APP_USER=1

declare    MYSQL_CLIENT_VERSION=""

declare    USE_SSL="no"
declare -i USE_SSL_OPTION=0

#
# Default value for max_connections in mysql_servers
#
declare    MAX_CONNECTIONS="1000"

#
# Default value for max-transactions-behind
#
declare -i MAX_TRANSACTIONS_BEHIND=100

#-------------------------------------------------------------------------------
#
# Step 3 : Helper functions
#

function error() {
  local lineno=$1
  shift
  if [[ -n "$lineno" ]]; then
    printf "${BD}ERROR${NBD} (line:$lineno) : ${*//%/%%}\n" 1>&2
  else
    printf "${BD}ERROR${NBD} : ${*//%/%%}\n" 1>&2
  fi
}

function warning() {
  local lineno=$1
  shift
  if [[ -n "$lineno" ]]; then
    printf "${BD}WARNING${NBD} (line:$lineno) : ${*//%/%%}\n" 1>&2
  else
    printf "${BD}WARNING${NBD}: ${*//%/%%}\n" 1>&2
  fi
}

function debug() {
  if [[ $DEBUG -eq 1 ]]; then
    local lineno=$1
    shift
    if [[ -n "$lineno" ]]; then
      printf "${RED}${BD}debug (line:$lineno) : ${*//%/%%}${NBD}${NRED}\n" 1>&2
    else
      printf "${RED}debug: ${*//%/%%}${NRED}\n" 1>&2
    fi
  fi
}

function dump_arguments() {
  local arg_list=""
  for arg do
    arg_list+=" '$arg'"
  done
  echo $arg_list
}


#
# Dispay script usage details
#
function usage() {
  local path=$0
  cat << EOF
Usage: ${path##*/} [ options ]
Options:
  --config-file=<config-file>        Read login credentials from a configuration file
                                     (command line options override any configuration file values)

  --writer-hostgroup=<number>        The hostgroup that all traffic will be sent to
                                     by default. Nodes that have 'read-only=0' in MySQL
                                     will be assigned to this hostgroup.
  --backup-writer-hostgroup=<number> If the cluster has multiple nodes with 'read-only=0'
                                     and max_writers set, then additional nodes (in excess
                                     of max_writers), will be assigned to this hostgroup.
  --reader-hostgroup=<number>        The hostgroup that read traffic should be sent to.
                                     Nodes with 'read-only=0' in MySQL will be assigned
                                     to this hostgroup.
  --offline-hostgroup=<number>       Nodes that are determined to be OFFLINE will
                                     assigned to this hostgroup.

  --proxysql-datadir=<datadir>       Specify the proxysql data directory location
  --proxysql-username=user_name      ProxySQL service username
  --proxysql-password[=password]     ProxySQL service password
  --proxysql-port=port_num           ProxySQL service port number
  --proxysql-hostname=host_name      ProxySQL service hostname

  --cluster-username=user_name       Percona XtraDB Cluster node username
  --cluster-password[=password]      Percona XtraDB Cluster node password
  --cluster-port=port_num            Percona XtraDB Cluster node port number
  --cluster-hostname=host_name       Percona XtraDB Cluster node hostname

  --cluster-app-username=user_name   Percona XtraDB Cluster node application username
  --cluster-app-password[=password]  Percona XtraDB Cluster node application passwrod
  --without-cluster-app-user         Configure Percona XtraDB Cluster without application user

  --monitor-username=user_name       Username for monitoring Percona XtraDB Cluster nodes through ProxySQL
  --monitor-password[=password]      Password for monitoring Percona XtraDB Cluster nodes through ProxySQL
  --use-existing-monitor-password    Do not prompt for a new monitor password if one is provided.

  --node-check-interval=<NUMBER>     Interval for monitoring node checker script (in milliseconds)
                                     (default: 3000)
  --mode=[loadbal|singlewrite]       ProxySQL read/write configuration mode
                                     currently supporting: 'loadbal' and 'singlewrite'
                                     (default: 'singlewrite')
  --write-node=<IPADDRESS>:<PORT>    Specifies the node that is to be used for
                                     writes for singlewrite mode.  If left unspecified,
                                     the cluster node is then used as the write node.
                                     This only applies when 'mode=singlewrite' is used.
  --max-connections=<NUMBER>         Value for max_connections in the mysql_servers table.
                                     This is the maximum number of connections that
                                     ProxySQL will open to the backend servers.
                                     (default: 1000)
  --max-transactions-behind=<NUMBER> Determines the maximum number of writesets a node
                                     can have queued before the node is SHUNNED to avoid
                                     stale reads.
                                     (default: 100)
  --use-ssl=[yes|no]                 If set to 'yes', then connections between ProxySQL
                                     and the backend servers will use SSL.
                                     (default: no)
  --debug                            Enables additional debug logging.
  --help                             Dispalys this help text.

These options are the possible operations for proxysql-admin.
One of the options below must be provided.
  --adduser                          Adds the Percona XtraDB Cluster application user to the ProxySQL database
  --disable, -d                      Remove any Percona XtraDB Cluster configurations from ProxySQL
  --enable, -e                       Auto-configure Percona XtraDB Cluster nodes into ProxySQL
  --update-cluster                   Updates the cluster membership, adds new cluster nodes
                                     to the configuration.
  --quick-demo                       Setup a quick demo with no authentication
  --syncusers                        Sync user accounts currently configured in MySQL to ProxySQL
                                     May be used with --enable.
                                     (deletes ProxySQL users not in MySQL)
  --sync-multi-cluster-users         Sync user accounts currently configured in MySQL to ProxySQL
                                     May be used with --enable.
                                     (doesn't delete ProxySQL users not in MySQL)
  --version, -v                      Prints the version info

EOF
}


# Checks the return value of the most recent command
#
# Globals:
#   None
#
# Arguments:
#   1: the error code of the most recent command
#   2: the lineno where the error occurred
#   3: the error message if the error code is non-zero
#
# Exits the script if the retcode is non-zero.
#
function check_cmd() {
  local retcode=$1
  local lineno=$2
  shift 2

  if [[ ${retcode} -ne 0 ]]; then
    error "$lineno" $*
    exit 1 
  fi
}


# Check the permissions for a file or directory
#
# Globals:
#   None
#
# Arguments:
#   1: the bash test to be applied to the file
#   2: the lineno where this call is invoked (used for errors)
#   3: the path to the file
#   4: (optional) description of the path (mostly used for existence checks)
#
# Exits the script if the permissions test fails.
#
function check_permission() {
  local permission=$1
  local lineno=$2
  local path_to_check=$3
  local description=""
  if [[ $# -gt 3 ]]; then
    description="$4"
  fi

  if [ ! $permission "$path_to_check" ] ; then
    if [[ $permission == "-r" ]]; then
      error "$lineno" "You do not have READ permission for: $path_to_check"
    elif [[ $permission == "-w" ]]; then
      error "$lineno" "You do not have WRITE permission for: $path_to_check"
    elif [[ $permission == "-x" ]]; then
      error "$lineno" "You do not have EXECUTE permission for: $path_to_check"
    elif [[ $permission == "-e" ]]; then
      if [[ -n $description ]]; then
        error "$lineno" "Could not find the $description: $path_to_check"
      else
        error "$lineno" "Could not find: $path_to_check"
      fi
    elif [[ $permission == "-d" ]]; then
      if [[ -n $description ]]; then
        error "$lineno" "Could not find the $description: $path_to_check"
      else
        error "$lineno" "Could not find the directory: $path_to_check"
      fi
    elif [[ $permission == "-f" ]]; then
      if [[ -n $description ]]; then
        error "$lineno" "Could not find the $description: $path_to_check"
      else
        error "$lineno" "Could not find the file: $path_to_check"
      fi
    else
      error "$lineno" "You do not have the correct permissions for: $path_to_check"
    fi
    exit 1
  fi
}


# Executes a SQL query with the (fully) specified server
#
# Globals:
#   DEBUG
#   TIMEOUT
#
# Arguments:
#   1: lineno
#   2: the name of the user
#   3: the user's password
#   4: the hostname of the server
#   5: the port used to connect to the server
#   6: the query to be run
#   7: (optional) arguments to the mysql client
#   8: (optional) additional options, space separated
#      Available options:
#       "hide_output"
#         This will not show the output of the query when DEBUG is set.
#         Used to stop the display of sensitve information (such as passwords)
#         from being displayed when debugging.
#
function exec_sql() {
  local lineno=$1
  local user=$2
  local password=$3
  local hostname=$4
  local port=$5
  local query=$6
  local args=""
  local more_options=""
  local retvalue
  local retoutput
  local default_auth=""

  if [[ $# -ge 7 ]]; then
    args=$7
  fi

  if [[ $# -ge 8 ]]; then
    more_options=$8
  fi

  debug "$lineno" "exec_sql : $user@$hostname:$port ==> $query"

  if [[ $MYSQL_CLIENT_VERSION == "8.0" ]]; then
    default_auth="default-auth=mysql_native_password"
  fi

  retoutput=$(mysql --defaults-file=/dev/stdin --protocol=tcp \
           --unbuffered --batch --silent ${args} -e "$query" <<EOF
[client]
user=${user//%/%%}
password="${password//%/%%}"
host=${hostname//%/%%}
port=${port//%/%%}
connect-timeout=${TIMEOUT}
${default_auth}
EOF
)
  retvalue=$?

  if [[ $DEBUG -eq 1 ]]; then
    local number_of_newlines=0
    local dbgoutput=$retoutput

    if [[ " $more_options " =~ [[:space:]]hide_output[[:space:]] ]]; then
      dbgoutput="**** data hidden ****"
    fi

    if [[ -n $dbgoutput ]]; then
      number_of_newlines=$(printf "%s" "${dbgoutput}" | wc -l)
    fi

    if [[ $retvalue -ne 0 ]]; then
      debug "" "--> query failed $retvalue"
    elif [[ -z $dbgoutput ]]; then
      debug "" "--> query returned $retvalue : <query returned no data>"
    elif [[ ${number_of_newlines} -eq 0 ]]; then
      debug "" "--> query returned $retvalue : ${dbgoutput}"
    else
      debug "" "--> query returned $retvalue : <data follows>"
      printf "%s\n" "${dbgoutput}" | while IFS= read -r line; do
        debug "" "----> $line"
      done
    fi
  fi

  printf "%s" "${retoutput}"
  return $retvalue
}


# Executes a SQL query on proxysql
#
# Globals:
#   PROXYSQL_USERNAME
#   PROXYSQL_PASSWORD
#   PROXYSQL_HOSTNAME
#   PROXYSQL_PORT
#
# Arguments:
#   1: lineno
#   2: The SQL query
#   3: (optional) Additional arguments to the mysql client for the query
#   4: (optional) more options, see exec_sql
#
function proxysql_exec() {
  local lineno=$1
  local query=$2
  local args=""
  local more_options=""

  if [[ $# -ge 3 ]]; then
    args=$3
  fi

  if [[ -z $args ]]; then
    args="--skip-column_names"
  fi

  if [[ $# -ge 4 ]]; then
    more_options=$4
  fi

  exec_sql "$lineno" "$PROXYSQL_USERNAME" "$PROXYSQL_PASSWORD" \
           "$PROXYSQL_HOSTNAME" "$PROXYSQL_PORT" \
           "$query" "$args" "$more_options"

  return $?
}

# Executes a SQL query on a specific node in the cluster
#
# Globals:
#   CLUSTER_USERNAME
#   CLUSTER_PASSWORD
#
# Arguments:
#   1: lineno
#   2: cluster host
#   3: cluster port
#   4: The SQL query
#   5: Additional arguments to the mysql client for the query
#   6: (optional) more options, see exec_sql
#
function cluster_exec() {
  local lineno=$1
  local cluster_host=$2
  local cluster_port=$3
  local query=$4
  local args=""
  local more_options=""

  if [[ $# -ge 5 ]]; then
    args=$5
  fi

  if [[ $# -ge 6 ]]; then
    more_options=$6
  fi

  exec_sql "$lineno" "$CLUSTER_USERNAME" "$CLUSTER_PASSWORD" \
           "$cluster_host" "$cluster_port" \
           "$query" "$args" "$more_options"

  return $?
}


# Executes a SQL query on the CLUSTER_HOSTNAME/CLUSTER_PORT
# specified in the config file.
#
# Globals:
#   CLUSTER_USERNAME
#   CLUSTER_PASSWORD
#   CLUSTER_HOSTNAME
#   CLUSTER_PORT
#
# Arguments:
#   1: lineno
#   2: The SQL query
#   3: Additional arguments to the mysql client for the query
#   4: (optional) more options, see exec_sql
#
function mysql_exec() {
  local lineno=$1
  local query=$2
  local args=""
  local more_options=""

  if [[ $# -ge 3 ]]; then
    args=$3
  fi

  if [[ $# -ge 4 ]]; then
    more_options=$4
  fi

  cluster_exec "$lineno" "$CLUSTER_HOSTNAME" "$CLUSTER_PORT" \
           "$query" "$args" "$more_options"

  return $?
}


# Executes a SQL query on a cluster ndde with the monitor credentials
#
# Globals:
#   CLUSTER_HOSTNAME
#   CLUSTER_PORT
#
# Arguments:
#   1: lineno
#   2: The monitor username
#   3: The monitor password
#   4: Additional arguments to the mysql client for the query
#   5: The SQL query
#   6: (optional) more options, see exec_sql
#
function monitor_exec() {
  local lineno=$1
  local user=$2
  local password=$3
  local args=$4
  local query=$5
  local more_options=""

  if [[ $# -ge 6 ]]; then
    more_options=$7
  fi

  exec_sql "$lineno" "$user" "$password" \
           "$CLUSTER_HOSTNAME" "$CLUSTER_PORT" \
           "$query" "$args" "$more_options"

  return $?
}

# Separates the IP address from the port in a network address
# Works for IPv4 and IPv6
#
# Globals:
#   None
#
# Params:
#   1. The network address to be parsed
#
# Outputs:
#   A string with a space separating the IP address from the port
#
function separate_ip_port_from_address()
{
  #
  # Break address string into host:port/path parts
  #
  local address=$1

  # Has to have at least one ':' to separate the port from the ip address
  if [[ $address =~ : ]]; then
    ip_addr=${address%:*}
    port=${address##*:}
  else
    ip_addr=$address
    port=""
  fi

  # Remove any braces that surround the ip address portion
  ip_addr=${ip_addr#\[}
  ip_addr=${ip_addr%\]}

  echo "${ip_addr} ${port}"
}

# Combines the IP address and port into a network address
# Works for IPv4 and IPv6
# (If the IP address is IPv6, the IP portion will have brackets)
#
# Globals:
#   None
#
# Params:
#   1: The IP address portion
#   2: The port
#
# Outputs:
#   A string containing the full network address
#
function combine_ip_port_into_address()
{
  local ip_addr=$1
  local port=$2
  local addr

  if [[ ! $ip_addr =~ \[.*\] && $ip_addr =~ .*:.* ]] ; then
    # If there are no brackets and it does have a ':', then add the brackets
    # because this is an unbracketed IPv6 address
    addr="[${ip_addr}]:${port}"
  else
    addr="${ip_addr}:${port}"
  fi
  echo "$addr"
}

# Check proxysql running status
#
# Globals:
#   None
#
# Arguments:
#   None
#
# Exits if we could not connect to the proxysql instance
#
function proxysql_connection_check() {
  proxysql_exec "$LINENO" "show tables" >/dev/null
  check_cmd $? "$LINENO" "ProxySQL connection check failed."\
                       "\n-- Could not connect to ProxySQL at $PROXYSQL_HOSTNAME:$PROXYSQL_PORT"\
                       "\n-- Please check the ProxySQL connection parameters and status."
  debug "$LINENO" "ProxySQL connection check succeeded"
}


# Check the PXC cluster running status
# (well one node in the cluster anyway)
#
# Globals:
#   None
#
# Arguments:
#   None
#
# Exits if we could not connect to a cluster node
#
function cluster_connection_check() {
  mysql_exec "$LINENO" "SELECT @@PORT" >/dev/null
  check_cmd $? "$LINENO" "PXC connection check failed."\
                       "\n-- Could not connect to the PXC cluster at $CLUSTER_HOSTNAME:$CLUSTER_PORT"\
                       "\n-- Please check the PXC connection parameters and status."
  debug "$LINENO" "cluster connection check succeeded"
}


# Queries the user for the proxysql connection parameters
#
# Globals:
#   PROYXSQL_HOST
#   PROXYSQL_PORT
#   PROXYSQL_USERNAME
#   PROXYSQL_PASSWORD
#
# Arguments:
#   None
#
function quickdemo_get_proxysql_params() {
  debug "$LINENO" "quickdemo_get_proxysql_params ()"
  read -r -p "Do you want to use the default ProxySQL credentials (admin:admin:6032:127.0.0.1) [y/n] ? " check_param
  case $check_param in
    y|Y)
      PROXYSQL_USERNAME="admin"
      PROXYSQL_PASSWORD="admin"
      PROXYSQL_PORT="6032"
      PROXYSQL_HOSTNAME="127.0.0.1"
    ;;
    n|N)
      echo ""
      echo -n "Enter the ProxySQL user name: "
      read -r PROXYSQL_USERNAME
      read -r -s -p  "Enter the ProxySQL user password: " PROXYSQL_PASSWORD;echo ""
      echo -n "Enter the ProxySQL port: "
      read -r PROXYSQL_PORT
      echo -n "Enter the ProxySQL hostname: "
      read -r PROXYSQL_HOSTNAME
      echo ""
    ;;
    *)
      error "" "Please type [y/n]!"
      exit 1
    ;;
  esac
}

# Queries the user for the PXC cluster connection parameters
#
# Globals:
#   CLUSTER_HOSTNAME
#   CLUSTER_PORT
#   CLUSTER_USERNAME
#   CLUSTER_PASSWORD
#
# Arguments:
#   None
#
function quickdemo_get_cluster_params() {
  debug "$LINENO" "quickdemo_get_cluster_params ()"
  read -r -p "Do you want to use the default Percona XtraDB Cluster credentials (root::3306:127.0.0.1) [y/n] ? " check_param
  case $check_param in
    y|Y)
      CLUSTER_USERNAME="root"
      CLUSTER_PASSWORD=""
      CLUSTER_PORT="3306"
      CLUSTER_HOSTNAME="127.0.0.1"
    ;;
    n|N)
      echo ""
      echo -n "Enter the Percona XtraDB Cluster username (super user): "
      read -r CLUSTER_USERNAME
      read -r -s -p  "Enter the Percona XtraDB Cluster user password: " CLUSTER_PASSWORD; echo ""
      echo -n "Enter the Percona XtraDB Cluster port: "
      read -r CLUSTER_PORT
      echo -n "Enter the Percona XtraDB Cluster hostname: "
      read -r CLUSTER_HOSTNAME
      echo ""
    ;;
    *)
      error "" "Please type [y/n]."
      exit 1
    ;;
  esac
}


# Checks for certain variables and prompts the user for
# the values if necessary.
#
# Globals:
#   QUICK_DEMO
#   MONITOR_USERNAME, MONITOR_PASSWORD
#   CLUSTER_APP_USERNAME, CLUSTER_APP_PASSWORD
#   CLUSTER_HOSTNAME, CLUSTER_USERNAME
#   USER_HOST_RANGE
# 
# Arguments:
#   1: the category for the variable, this may either be MONITOR or CLUSTER_APP
#   2: a description of the user
#   3: the hostgroup to associate the user with
#     (only needed if user_category='CLISTER APP')
#
function user_input_check() {
  debug "$LINENO" "user_input_check ( $(dump_arguments "$@") )"
  local user_category=$1
  local user_description=$2
  local hostgroup_id
  local username
  local password

  if [[ $user_category == "CLUSTER_APP" ]]; then
    hostgroup_id=$3
  fi

  username=$(eval "echo \$${user_category}_USERNAME")
  password=$(eval "echo \$${user_category}_PASSWORD")

  if [[ -z $username ]]; then
    read -r -p "Enter ${user_description}name : " ${user_category}_USERNAME
    while [[ -z "${user_category}_USERNAME" ]]
    do
      echo -n "No input entered, Enter ${user_description} name: "
      read -r ${user_category}_USERNAME
    done
  else
    if [[ $QUICK_DEMO -eq 0 ]]; then
      echo -e "${user_description} name as per command line/config-file is ${BD}$(eval "echo \$${user_category}_USERNAME")${NBD}"
    fi
  fi
  if [[ -z $password ]]; then
    if [[ $QUICK_DEMO -eq 0 ]]; then
      read -r -s -p  "Enter ${user_description} password: " ${user_category}_PASSWORD
      password=$(eval "echo \$${user_category}_PASSWORD")
      while [[ -z $password ]]
      do
        read -r -s -p  "No input entered, Enter ${user_description} password: " ${user_category}_PASSWORD
        password=$(eval "echo \$${user_category}_PASSWORD")
      done
    fi
  fi
  username=$(eval "echo \$${user_category}_USERNAME")
  password=$(eval "echo \$${user_category}_PASSWORD")

  if [[ $user_category == "CLUSTER_APP" ]]; then
    local check_user
    check_user=$(mysql_exec "$LINENO" "SELECT user,host FROM mysql.user where user='$username' and host='$USER_HOST_RANGE';")
    check_cmd $? "$LINENO" "Failed to retrieve the user information from PXC."\
                         "\n-- Please check the PXC connection parameters and status."

    if [[ -z "$check_user" ]]; then
      local precheck_user
      precheck_user=$(proxysql_exec "$LINENO" "SELECT username FROM mysql_users where username='$username'")
      check_cmd $? "$LINENO" "Failed to query ProxySQL for the user."\
                           "\n-- Please check the ProxySQL connection parameters and status."

      if [[ -z "$precheck_user" ]]; then
        mysql_exec "$LINENO" "CREATE USER $username@'$USER_HOST_RANGE' IDENTIFIED WITH mysql_native_password BY '$password';"
        check_cmd $? "$LINENO" "Failed to add the PXC application user to PXC: $username" \
                             "\n-- Please check if '$CLUSTER_USERNAME'@'$CLUSTER_HOSTNAME' has the proper permissions to create the montioring user"

        if [[ $QUICK_DEMO -eq 1 ]]; then
          mysql_exec "$LINENO" "GRANT ALL ON *.* to $username@'$USER_HOST_RANGE'"
          check_cmd $? "$LINENO" "Failed to grant permissions to '$username'@'$USER_HOST_RANGE'"\
                               "\n-- Please check if $CLUSTER_USERNAME@'$CLUSTER_HOSTNAME' has the GRANT privilege"\
                               "\n-- required to assign the requested permissions"
        fi

        proxysql_exec "$LINENO" "INSERT INTO mysql_users (username,password,active,default_hostgroup) values ('$username','$password',1,$hostgroup_id);"
        check_cmd $? "$LINENO" "Failed to add the PXC application user: '$username' to the ProxySQL database."\
                             "\n-- Please check the ProxySQL connection parameters and status."

        proxysql_load_to_runtime_save_to_disk "MYSQL USERS" "$LINENO" 1
    
        if [[ $QUICK_DEMO -eq 0 ]]; then
          echo -e "\nPercona XtraDB Cluster application user '${BD}$username'@'$USER_HOST_RANGE${NBD}' has been added with ${BD}ALL${NBD} privileges, ${BD}this user is created for testing purposes${NBD}"
        else
          echo -e "\nPercona XtraDB Cluster application user '${BD}$username'@'$USER_HOST_RANGE${NBD}' has been added with the USAGE privilege, please make sure to the grant appropriate privileges"
        fi
      else
        error "$LINENO" "The application user ${BD}$username${NBD} is already present in the ProxySQL database."
        echo -e "-- Note: ProxySQL does not allow duplicate usernames."
        exit 1
      fi
    else
      local check_user
      check_user=$(proxysql_exec "$LINENO" "SELECT username FROM mysql_users where username='$username'")
      check_cmd $? "$LINENO" "Could not retrieve the users from the ProxySQL database."\
                           "\n-- Please check the ProxySQL connection parameters and status."

      if [[ -z "$check_user" ]]; then
        echo -e "\nApplication user '${BD}${username}'@'$USER_HOST_RANGE${NBD}' already present in PXC."
        proxysql_exec "$LINENO" "INSERT INTO mysql_users (username,password,active,default_hostgroup) values ('$username','$password',1,$hostgroup_id);"
        check_cmd $? "$LINENO" "Failed to add the PXC application user: '$username' to the ProxySQL database."\
                             "\n-- Please check the ProxySQL connection parameters and status."

        proxysql_load_to_runtime_save_to_disk "MYSQL USERS" "$LINENO" 1
      else
        error "$LINENO" "The application user ${BD}$username${NBD} is already present in the ProxySQL database."
        echo -e "-- Note: ProxySQL does not allow duplicate usernames."
        exit 1
      fi
    fi
  fi
}


# This will move the configuration from memory to the runtime (load)
# and from memory to disk (save)
#
# Globals:
#   None
#
# Arguments:
#   1: the proxysql data that is being loaded and saved
#      (for example "MYSQL USERS" or "MYSQL SERVERS").
#   2: the lineno where this function was invoked
#
# This function will exit the program if an error occurs while
# loaded to runtime or saving to disk.
#
function proxysql_load_to_runtime_save_to_disk() {
  local data_type=$1
  local lineno=$2
  local reload_from_runtime=0

  if [[ $# -ge 3 ]]; then
    reload_from_runtime=$3
  fi

  proxysql_exec "$LINENO" "LOAD ${data_type} TO RUNTIME"
  check_cmd $? "$lineno" "Failed to load the ${data_type} configuration to runtime."\
                       "\n-- Please check the ProxySQL configuration and status."
  debug "$lineno" "Loaded ${data_type} to runtime"

  if [[ $reload_from_runtime -eq 1 ]]; then
    # This has a specific purpose for the MYSQL USERS
    # This will cause the password field to be loaded with the encrypted version
    # of the password field
    proxysql_exec "$LINENO" "SAVE ${data_type} FROM RUNTIME"
    check_cmd $? "$lineno" "Failed to load the ${data_type} configuration from the runtime."\
                         "\n-- Please check the ProxySQL configuration and status."
    debug "$lineno" "Saved ${data_type} from runtime"
  fi

  proxysql_exec "$LINENO" "SAVE ${data_type} TO DISK;"
  check_cmd $? "$lineno" "Failed to save the ${data_type} configuration to disk."\
                       "\n-- Please check the ProxySQL configuration and status."
  debug "$lineno" "Saved ${data_type} to disk"
}

# Adds the list of servers to ProxySQL
# This will add all of the servers in the list to the WRITER hostgroup
# ProxySQL is responsible for moving them to the correct hostgroup
#
# Globals:
#   WRITER_HOSTGROUP_ID
#   MAX_CONNECTIONS
#   USE_SSL_OPTION
#
# Arguments:
#   Parameter 1 : A list of servers (space-separated in a string)
#
function add_servers_to_proxysql()
{
  local server_list=$1
  for i in ${server_list}; do
    local ws_address ws_ip ws_port
    ws_address=$(separate_ip_port_from_address "$i")
    ws_ip=$(echo "$ws_address" | cut -d' ' -f1)
    ws_port=$(echo "$ws_address" | cut -d' ' -f2)

    proxysql_exec "$LINENO" \
      "INSERT INTO mysql_servers
        (hostname,hostgroup_id,port,weight,max_connections,use_ssl)
      VALUES
        ('$ws_ip',$WRITER_HOSTGROUP_ID,$ws_port,1000,$MAX_CONNECTIONS,$USE_SSL_OPTION);"
    check_cmd $? "$LINENO" "Failed to add the PXC server node with address: $i."\
                         "\n-- Please check the ProxySQL connection parameters and status."
  done
}

# Auto configure Percona XtraDB Cluster nodes into ProxySQL
#
# Globals:
#   READER_HOSTGROUP_ID, WRITER_HOSTGROUP_ID, BACKUP_WRITER_HOSTGROUP_ID, OFFLINE_HOSTGROUP_ID
#   CLUSTER_NETWORK
#   CLUSTER_PORT
#   USER_HOST_RANGE
#   MONITOR_USERNAME, MONITOR_PASSWORD
#   CLUSTER_APP_USERNAME, CLUSTER_APP_PASSWORD
#   CLUSTER_USERNAME, CLUSTER_HOSTNAME
#   USE_EXISTING_MONITOR_PASSWORD
#   WITH_CLUSTER_APP_USER
#   QUICK_DEMO
#   WRITE_NODE
#   MODE
#
# Arguments:
#   None
#
function enable_proxysql() {
  debug "$LINENO" "enable_proxysql ()"

  # Checking proxysql binary location
  if [[ ! -e $(which proxysql 2> /dev/null) ]]; then
    error "$LINENO" "The proxysql binary was not found."\
                  "\n-- Please install the ProxySQL package."
    exit 1
  fi

  # Check for existing proxysql process
  proxysql_connection_check
  
  cluster_connection_check
  local cluster_name
  cluster_name=$(mysql_exec "$LINENO" "select @@wsrep_cluster_name;")
  check_cmd $? "$LINENO" "Could not retrieve the cluster name from the PXC cluster at $CLUSTER_HOSTNAME:$CLUSTER_PORT"\
                       "\n-- Please check the PXC connection parameters and status."
  readonly cluster_name
  debug "$LINENO" "PXC cluster name is : $cluster_name"

  local all_hostgroups="$WRITER_HOSTGROUP_ID,$READER_HOSTGROUP_ID,$BACKUP_WRITER_HOSTGROUP_ID,$OFFLINE_HOSTGROUP_ID"
  local check_hgs

  # First, check to see if mysql_galera_hostgroups is using any of these
  # hostgroups
  check_hgs=$(proxysql_exec "$LINENO" \
    "SELECT COUNT(*)
      FROM mysql_galera_hostgroups
      WHERE
        writer_hostgroup IN ($all_hostgroups) OR
        reader_hostgroup IN ($all_hostgroups) OR
        backup_writer_hostgroup IN ($all_hostgroups) OR
        offline_hostgroup IN ($all_hostgroups)")
  check_cmd $? "$LINENO" "Could not retrieve hostgroup information from ProxySQL"\
                       "\n-- Please check the ProxySQL connection parameters and status."
  if [[ -n $check_hgs && $check_hgs -ne 0 ]]; then
    error "$LINENO" "One or more of the hostgroups($all_hostgroups) is already being used" \
                  "\n-- by ProxySQL in mysql_galera_hostgroups." \
                  "\n-- To avoid conflicts, please use different values for the hostgroups."
    proxysql_exec "$LINENO" \
      "SELECT
          writer_hostgroup AS writer,
          reader_hostgroup AS reader,
          backup_writer_hostgroup AS backup_writer,
          offline_hostgroup AS offline,
          comment
        FROM mysql_galera_hostgroups
        WHERE
          writer_hostgroup IN ($all_hostgroups) OR
          reader_hostgroup IN ($all_hostgroups) OR
          backup_writer_hostgroup IN ($all_hostgroups) OR
          offline_hostgroup IN ($all_hostgroups)" "-t"
    echo ""
    exit 1
  fi

  # Now, check to see if there are any entries in mysql_servers
  # using these hostgroups
  check_hgs=$(proxysql_exec "$LINENO" \
    "SELECT hostgroup_id
      FROM mysql_servers
      WHERE
        hostgroup_id IN ($all_hostgroups) AND
        status <> 'OFFLINE_HARD'")
  check_cmd $? "$LINENO" "Could not retrieve hostgroup and server information from ProxySQL"\
                       "\n-- Please check the ProxySQL connection parameters and status."
  if [[ -n "$check_hgs" ]]; then
    error "$LINENO" "One or more of the hostgroups($all_hostgroups) has a server assigned to that hostgroup."\
                  "\n-- To avoid conflicts, please use different values for the hostgroups."
    proxysql_exec "$LINENO" \
      "SELECT
          hostgroup_id,
          hostname,
          port,
          status,
          weight
        FROM mysql_servers
        WHERE
          hostgroup_id IN ($all_hostgroups)" "-t"
    echo ""
    exit 1
  fi

  # Clear out any servers that are OFFLINE_HARD
  # If --disable is called, then --enable is called quickly afterwards,
  # ProxySQL may still be updating the previous server list.  So this
  # will remove any leftovers in the runtime_mysql_servers table
  proxysql_exec "$LINENO" \
    "DELETE
      FROM mysql_servers
      WHERE
        hostgroup_id in ($all_hostgroups) AND
        status = 'OFFLINE_HARD'"
  check_cmd $? "$LINENO" "Could not delete offline servers from ProxySQL"\
                       "\n-- Please check the ProxySQL connection parameters and status."


  CLUSTER_NETWORK=$(mysql_exec "$LINENO" "show status like 'wsrep_incoming_addresses'" |
                      awk '{print $2}' |
                      cut -d'.' -f1)
  check_cmd $? "$LINENO" "Could not retrieve the cluster addresses from PXC."\
                       "\n-- Please check the PXC connection parameters and status."
  if [[ "$CLUSTER_NETWORK" =~ ^[0-9]+$ ]]; then 
    USER_HOST_RANGE="$CLUSTER_NETWORK.%"
  else
    USER_HOST_RANGE="%"
  fi

  echo -e "\nConfiguring the ProxySQL monitoring user."
  user_input_check MONITOR "ProxySQL monitor user"
  readonly MONITOR_USERNAME

  local check_user
  check_user=$(mysql_exec "$LINENO" "SELECT user,host FROM mysql.user where user='$MONITOR_USERNAME' and host='$USER_HOST_RANGE';")
  check_cmd $? "$LINENO" "Could not retrieve the monitor user information from PXC."\
                       "\n-- Please check the PXC cluster connection parameters and status."
  if [[ -z "$check_user" ]]; then
    # No monitor user found in MySQL, create the monitor user
    mysql_exec "$LINENO" "CREATE USER '$MONITOR_USERNAME'@'$USER_HOST_RANGE' IDENTIFIED WITH mysql_native_password BY '$MONITOR_PASSWORD';"
    check_cmd $? "$LINENO"  "Failed to create the ProxySQL monitoring user."\
                          "\n-- Please check that '$CLUSTER_USERNAME'@'$CLUSTER_HOSTNAME' has the proper permissions to create the montioring user"

    proxysql_exec "$LINENO" "update global_variables set variable_value='$MONITOR_USERNAME' where variable_name='mysql-monitor_username'; update global_variables set variable_value='$MONITOR_PASSWORD' where variable_name='mysql-monitor_password'; "
    check_cmd $? "$LINENO"  "Failed to set the mysql-monitor variables in ProxySQL."\
                          "\n-- Please check the ProxySQL connection parameters and status."

    proxysql_load_to_runtime_save_to_disk "MYSQL VARIABLES" $LINENO

    echo -e "\nUser '${BD}$MONITOR_USERNAME'@'$USER_HOST_RANGE${NBD}' has been added with USAGE privileges"
  else
    # Monitor user found in MySQL, do we want to use this existing user?
    local check_param

    if [[ $USE_EXISTING_MONITOR_PASSWORD -eq 1 ]]; then
      # We have a password, so no need to ask for a new password
      check_param="n"
    else
      echo ""
      echo -e "The monitoring user is already present in Percona XtraDB Cluster.\n"
      read -p "Would you like to enter a new password [y/n] ? " check_param
    fi
    case $check_param in
      y|Y)
        if [[ $QUICK_DEMO -eq 0 ]]; then
          read -r -s -p  "Please enter the password you have assigned to the monitoring user '$MONITOR_USERNAME': " MONITOR_PASSWORD
          echo ""

          monitor_exec "$LINENO" "$MONITOR_USERNAME" "$MONITOR_PASSWORD" "-Bs" "SELECT 1" >/dev/null
          check_cmd $? "$LINENO" "Failed to connect to Percona XtraDB Cluster using monitor credentials."\
                               "\n-- Please check MONITOR_USERNAME and MONITOR_PASSWORD"

          proxysql_exec "$LINENO" "update global_variables set variable_value='$MONITOR_USERNAME' where variable_name='mysql-monitor_username'; update global_variables set variable_value='$MONITOR_PASSWORD' where variable_name='mysql-monitor_password'; "
          check_cmd $? "$LINENO"  "Failed to set the mysql-monitor variables in ProxySQL."\
                                "\n-- Please check the ProxySQL connection parameters"
          proxysql_load_to_runtime_save_to_disk "MYSQL VARIABLES" $LINENO
          echo -e "\nMonitoring user '${BD}$MONITOR_USERNAME'@'$USER_HOST_RANGE${NBD}' has been setup in the ProxySQL database."
        fi
      ;;
      n|N)
        monitor_exec "$LINENO" "$MONITOR_USERNAME" "$MONITOR_PASSWORD" "-Bs" "SELECT 1" >/dev/null
        check_cmd $? "$LINENO" "Failed to connect to Percona XtraDB Cluster using monitor credentials."\
                             "\n-- Please check MONITOR_USERNAME and MONITOR_PASSWORD"

        proxysql_exec "$LINENO" "update global_variables set variable_value='$MONITOR_USERNAME' where variable_name='mysql-monitor_username'; update global_variables set variable_value='$MONITOR_PASSWORD' where variable_name='mysql-monitor_password'; "
        check_cmd $? "$LINENO"  "Failed to set the mysql-monitor variables in ProxySQL."\
                              "\n-- Please check the ProxySQL connection parameters"

        proxysql_load_to_runtime_save_to_disk "MYSQL VARIABLES" $LINENO
        echo -e "\nMonitoring user '${BD}$MONITOR_USERNAME'@'$USER_HOST_RANGE${NBD}' has been setup in the ProxySQL database."
      ;;
      *)
        error "" "Please type [y/n]!"
        exit 1
      ;;
    esac
  fi
  debug "$LINENO" "monitor username is '$MONITOR_USERNAME'"

  if [[ $WITH_CLUSTER_APP_USER -eq 1 ]]; then
    echo -e "\nConfiguring the Percona XtraDB Cluster application user to connect through ProxySQL"
    user_input_check CLUSTER_APP "Percona XtraDB Cluster application user" $WRITER_HOSTGROUP_ID
    readonly CLUSTER_APP_USERNAME
    readonly CLUSTER_APP_PASSWORD
  fi

  # Adding Percona XtraDB Cluster nodes to ProxySQL
  # -----------------------------------------------

  # Get the nodes in the cluster
  wsrep_address=$(mysql_exec "$LINENO" "show status like 'wsrep_incoming_addresses'" | awk '{print $2}' | sed 's|,| |g')
  debug "$LINENO" "wsrep_address = $wsrep_address"
  check_cmd $? "$LINENO" "Failed to get the list of addresses from PXC"\
                       "\n-- Please check the PXC connection paramters and status."

  echo -e "\nAdding the Percona XtraDB Cluster server nodes to ProxySQL"

  local writer_ws_ip
  local writer_ws_port
  local writer_ws_address

  # Perform some sanity checks before proceeding
  if [[ $MODE == 'singlewrite' ]]; then
    if [[ $QUICK_DEMO -eq 0 ]]; then

      if [ -z "$WRITE_NODE" ]; then
        # If there is no WRITE_NODE specified, assume that the cluster node
        # is THE write node
        writer_ws_ip=$(mysql_exec "$LINENO" "show variables like 'wsrep_provider_options'" |
                        grep -o -P '(?<=base_host =).*(?=; base_port)' |
                        xargs)
        writer_ws_port=$CLUSTER_PORT
        writer_ws_address=$(combine_ip_port_into_address "$writer_ws_ip" "$writer_ws_port")
      else
        writer_ws_address=$(separate_ip_port_from_address "$WRITE_NODE")
        writer_ws_ip=$(echo "$writer_ws_address" | cut -d' ' -f1)
        writer_ws_port=$(echo "$writer_ws_address" | cut -d' ' -f2)
        if [ -z "$writer_ws_port" ];then
          writer_ws_port=3306
        fi
        writer_ws_address=$(combine_ip_port_into_address "$writer_ws_ip" "$writer_ws_port")

        # TODO: kennt, do we want to display the error message?
        # TODO: kennt, Do we want to do this for loadbal also?
        exec_sql "$LINENO" "$CLUSTER_USERNAME" "$CLUSTER_PASSWORD" "$writer_ws_ip" "$writer_ws_port" "select @@port" &>/dev/null
        if [ $? -ne 0 ]; then 
          error "$LINENO" "Failed to establish a connection to the write node $writer_ws_address."\
                        "\n-- Please check that the write node is alive and the connection parameters are correct"; 
          proxysql_exec "$LINENO" "DELETE FROM mysql_users WHERE default_hostgroup in ($WRITER_HOSTGROUP_ID,$READER_HOSTGROUP_ID,$BACKUP_WRITER_HOSTGROUP_ID,$OFFLINE_HOSTGROUP_ID);"
          check_cmd $? "$LINENO" "Failed to delete PXC user from ProxySQL."\
                               "\n-- Please check the ProxySQL connection parameters and status."
          exit 1
        fi
      fi
    else
      writer_ws_ip=$(mysql_exec "$LINENO" "show variables like 'wsrep_provider_options'" | grep -o -P '(?<=base_host =).*(?=; base_port)' | xargs)
      check_cmd $? "$LINENO" "Could not get the wsrep_provider_options from the PXC cluster"\
                           "\n-- Please check the PXC connection parameters and status."      
      writer_ws_port=$CLUSTER_PORT
      writer_ws_address=$(combine_ip_port_into_address "$writer_ws_ip" "$writer_ws_port")
    fi

    if [[ " ${wsrep_address} " != *"$writer_ws_address"* ]]; then
      error "$LINENO" "Writer node cluster address($writer_ws_address) does not exist"\
                    "\n-- in WSREP incoming address(${wsrep_address})."
      echo -e "-- Different wsrep incoming and cluster IP addresses are not supported"
      echo -e "-- by proxysql-admin at this time.  Please configure ProxySQL manually."
      exit 1
    fi
  fi

  # Remove any existing nodes from mysql_servers
  proxysql_exec "$LINENO" "DELETE FROM mysql_servers WHERE hostgroup_id IN ($all_hostgroups)"
  check_cmd $? "$LINENO" "Failed to delete the existing servers with hostgroup: ${all_hostgroups}"\
                       "\n-- Please check the ProxySQL connection parameters and status."

  # Remove any existing query rules
  proxysql_exec "$LINENO" "DELETE FROM mysql_query_rules WHERE destination_hostgroup in ($all_hostgroups)"
  check_cmd $? "$LINENO" "Failed to delete the existing query rules for hostgroup: $all_hostgroups"\
                       "\n-- Please check the ProxySQL connection parameters and status."
  # TODO: also remove fast query rules

  # Add all nodes as writer nodes (to begin with)
  add_servers_to_proxysql "${wsrep_address}"

  if [[ $MODE == "loadbal" ]]; then
    # loadbal for ProxySQL 2.0
    # All nodes are writers (so number of writers is a very large number)
    # All queries go to the write hostgroup
    # All nodes have read_only=0
    # (Reader hostgroup doesn't matter)
    # writer-is-also-reader=0, since we only have writers

    # Setup parameters for loadbal
    MAX_WRITERS=1000000
    WRITER_IS_ALSO_READER=0

  elif [[ $MODE == "singlewrite" ]]; then
    # singlewrite for ProxySQL 2.0
    # Number of writers is 1
    # Query rules added so writes go to write hostgroup
    # Reads go to read hostgroup
    # Also writer-is-also-reader=2 (so that backup writers get reads)
    # Must have at least one node with read-only = 0

    # TODO: kennt, Check to see that the write_node has read-only=0

    # Update the write_node to have a higher priority
    proxysql_exec "$LINENO" \
      " UPDATE mysql_servers SET
          weight = 1000000
        WHERE
          hostname = '$writer_ws_ip' AND
          port = $writer_ws_port AND
          hostgroup_id = $WRITER_HOSTGROUP_ID;"
    check_cmd $? "$LINENO" "Failed to update the writer-node for singlewrite mode" \
                             "\n-- Please check the ProxySQL connection parameters and status."

    echo -e "\nWrite node info"
    proxysql_exec "$LINENO" \
      "SELECT hostname,hostgroup_id,port,weight
       FROM mysql_servers
       WHERE hostgroup_id=$WRITER_HOSTGROUP_ID AND weight > 1000" "-t"

    if [[ $WITH_CLUSTER_APP_USER -eq 1 ]]; then
      proxysql_exec "$LINENO" \
        "INSERT INTO mysql_query_rules
          (username,destination_hostgroup,active,match_digest,apply)
         VALUES
          ('$CLUSTER_APP_USERNAME',$WRITER_HOSTGROUP_ID,1,'^SELECT.*FOR UPDATE',1),
          ('$CLUSTER_APP_USERNAME',$READER_HOSTGROUP_ID,1,'^SELECT ',1);"

      check_cmd $? "$LINENO" "Failed to add the read query rule to ProxySQL."\
                           "\n-- Please check the ProxySQL connection parameters and status."
    fi

    # Setup parameters for singlewrite
    MAX_WRITERS=1
    WRITER_IS_ALSO_READER=1
  fi

  if [[ $NODE_CHECK_INTERVAL -ne -1 ]]; then
    local healthcheck_value
    healthcheck_value=$(proxysql_exec "$LINENO" "select variable_value from global_variables where variable_name = 'mysql-monitor_galera_healthcheck_interval'" |
                                grep -v variable_value)
    check_cmd $? "$LINENO" "Failed to get the node-check-interval value from ProxySQL."\
                         "\n-- Please check the ProxySQL connection parameters and status."
    if [[ $healthcheck_value -ne $NODE_CHECK_INTERVAL ]]; then
      warning "$LINENO" "Changing the node check interval to :$NODE_CHECK_INTERVAL" \
              "\n-- This is a global setting and will affect all Galera clusters"

      proxysql_exec "$LINENO" "SET mysql-monitor_galera_healthcheck_interval  = $NODE_CHECK_INTERVAL"
      check_cmd $? "$LINENO" "Failed to set the node-check-interval in ProxySQL."\
                           "\n-- Please check the ProxySQL connection parameters and status."
    fi
  fi

  proxysql_exec "$LINENO" \
    "INSERT INTO mysql_galera_hostgroups (writer_hostgroup,
                                         backup_writer_hostgroup,
                                         reader_hostgroup,
                                         offline_hostgroup,
                                         active,
                                         max_writers,
                                         writer_is_also_reader,
                                         max_transactions_behind)
        VALUES
          ($WRITER_HOSTGROUP_ID, $BACKUP_WRITER_HOSTGROUP_ID,
           $READER_HOSTGROUP_ID, $OFFLINE_HOSTGROUP_ID,
           1, $MAX_WRITERS, $WRITER_IS_ALSO_READER, $MAX_TRANSACTIONS_BEHIND)"
  check_cmd $? "$LINENO" "Failed to create the galera_hostgroups entry in ProxySQL."\
                       "\n-- Please check the ProxySQL connection parameters and status."

  proxysql_load_to_runtime_save_to_disk "MYSQL VARIABLES" $LINENO
  proxysql_load_to_runtime_save_to_disk "MYSQL SERVERS" $LINENO
  proxysql_load_to_runtime_save_to_disk "MYSQL QUERY RULES" $LINENO
}

# Removing Percona XtraDB Cluster configuration from proxysql
#
# Globals:
#   CLUSTER_HOSTNAME, CLUSTER_PORT
#   CLUSTER_APP_USERNAME
#   WRITER_HOSTGROUP_ID
#   READER_HOSTGROUP_ID
#
# Arguments:
#
function disable_proxysql(){
  debug "$LINENO" "disable_proxysql ()"

  proxysql_connection_check

  local all_hostgroups="$WRITER_HOSTGROUP_ID,$READER_HOSTGROUP_ID,$BACKUP_WRITER_HOSTGROUP_ID,$OFFLINE_HOSTGROUP_ID"

  echo "Removing default cluster application user from the ProxySQL database."
  proxysql_exec "$LINENO" "DELETE FROM mysql_users WHERE username='$CLUSTER_APP_USERNAME';"
  check_cmd $? "$LINENO" "Failed to delete the PXC user ($CLUSTER_APP_USERNAME) from ProxySQL."\
                       "\n-- Please check the ProxySQL connection parameters and status."

  echo "Removing cluster nodes from the ProxySQL database."
  proxysql_exec "$LINENO" "DELETE FROM mysql_servers WHERE hostgroup_id in ($all_hostgroups);"
  check_cmd $? "$LINENO" "Failed to delete the PXC nodes from ProxySQL."\
                       "\n-- Please check the ProxySQL connection parameters and status."

  echo "Removing query rules from the ProxySQL database if any."
  proxysql_exec "$LINENO" "DELETE FROM mysql_query_rules WHERE destination_hostgroup in ($all_hostgroups)"
  check_cmd $? "$LINENO" "Failed to delete the query rules from ProxySQL."\
                       "\n-- Please check the ProxySQL connection parameters amd status."

  echo "Removing the cluster from the ProxySQL database."
  proxysql_exec "$LINENO" "DELETE FROM mysql_galera_hostgroups WHERE writer_hostgroup = $WRITER_HOSTGROUP_ID"
  check_cmd $? "$LINENO" "Failed to delete the galera hostgroup entry from ProxySQL."\
                       "\n-- Please check the ProxySQL connection parameters amd status."

  # TODO: do we need to remove the rows from the fast query routing table?

  proxysql_load_to_runtime_save_to_disk "MYSQL USERS" $LINENO
  proxysql_load_to_runtime_save_to_disk "MYSQL SERVERS" $LINENO
  proxysql_load_to_runtime_save_to_disk "MYSQL QUERY RULES" $LINENO
}

# Adds an application user to ProxySQL
#
# Globals:
#   WRITER_HOSTGROUP_ID
#
# Arguments:
#   None
#
function adduser(){
  debug "$LINENO" "adduser ()"

  proxysql_connection_check
  cluster_connection_check

  local cluster_app_write_username
  local cluster_app_write_password

  echo -e "\nAdding PXC application user to the ProxySQL database"
  echo -n "Enter the PXC application user name: "
  read -r cluster_app_write_username
  while [[ -z "$cluster_app_write_username" ]]
  do
    echo -n "No input entered. Enter the PXC application user name: "
    read -r cluster_app_write_username
  done
  read -r -s -p  "Enter the PXC application user password: " cluster_app_write_password
  while [[ -z "$cluster_app_write_password" ]]
  do
    read -r -s -p  "No input entered. Enter the PXC application user password: " cluster_app_write_password
  done

  # check to see if the user already exists
  local check_user
  local check_cluster_user

  check_user=$(proxysql_exec "$LINENO" "SELECT username FROM mysql_users where username='$cluster_app_write_username'")
  check_cmd $? "$LINENO" "Could not retrieve the user from ProxySQL."\
                       "\n-- Check the ProxySQL connection parameters and status."
  if [[ -n "$check_user" ]]; then
    error "$LINENO" "The application user '$cluster_app_write_username' already exists in ProxySQL."
    exit 1
  fi

  check_cluster_user=$(mysql_exec "$LINENO" "SELECT user,host FROM mysql.user where user='$cluster_app_write_username'")
  check_cmd $? "$LINENO" "Could not retrieve the user from PXC."\
                       "\n-- Check the PXC connection parameters and status."
  if [[ -z "$check_cluster_user" ]]; then
    local check_param
    echo -e "\n\n"
    read -r -p "The application user '$cluster_app_write_username' does not exist in PXC. Would you like to proceed [y/n] ? " check_param
    case $check_param in
      y|Y)
        proxysql_exec "$LINENO" \
          "INSERT INTO mysql_users
            (username,password,active,default_hostgroup)
           VALUES
            ('$cluster_app_write_username','$cluster_app_write_password',1,$WRITER_HOSTGROUP_ID);"
        check_cmd $? "$LINENO" "Failed to add the PXC application user: '$cluster_app_write_username' to ProxySQL."\
                             "\n-- Please check the ProxySQL connection parameters and status."
        echo -e "\nPlease create the user ${BD}$cluster_app_write_username${NBD} in PXC to access the application through ProxySQL"
      ;;
      n|N)
        exit 0
      ;;
      *)
        error "" "Please type [y/n]!"
        exit 1
      ;;
    esac
  else
    proxysql_exec "$LINENO" \
      "INSERT INTO mysql_users
          (username,password,active,default_hostgroup)
       values
          ('$cluster_app_write_username','$cluster_app_write_password',1,$WRITER_HOSTGROUP_ID);"
    check_cmd $? "$LINENO" "Failed to add the PXC application user: '$cluster_app_write_username' to ProxySQL."\
                         "\n-- Please check the ProxySQL connection parameters and status."
  fi

  proxysql_load_to_runtime_save_to_disk "MYSQL USERS" "$LINENO" "1"
}


# Returns a list of users from the ProxySQL database
#
# Globals:
#   WRITER_HOSTGROUP_ID
#
# Arguments:
#   None
#
function get_proxysql_users() {
  local proxysql_users
  proxysql_users=$(proxysql_exec "$LINENO" \
                    "SELECT username,password
                      FROM mysql_users
                      WHERE password!='' AND default_hostgroup=$WRITER_HOSTGROUP_ID" "" "hide_output")
  check_cmd $? "$LINENO" "Failed to load user list from ProxySQL database."\
                       "\n-- Please check the ProxySQL connection parameters and status."
  proxysql_users=$(echo "$proxysql_users" |
                      sort |
                      uniq )
  printf "%s" "$proxysql_users"
}


# Checks if a user is a ProxySQL admin user
#
# Globals:
#   None
#
# Arguments:
#   1: the name of the use to be checked
#
# Outputs (to stdout):
#   1 if the user is a proxysql admin user
#   0 if the user is not a proxysql admin user
#
function proxysql_admin_user_check(){
  local userchk=$1
  local proxysql_admin_users
  local is_proxysql_admin_user

  proxysql_admin_users=($(proxysql_exec "$LINENO" "select variable_value from global_variables where variable_name like 'admin-%_credentials'" |
                              cut -d':' -f1 |
                              grep -v variable_value))
  if [[ " ${proxysql_admin_users[@]} " =~ [[:space:]]${userchk}[[:space:]] ]]; then
    is_proxysql_admin_user=1
  else
    is_proxysql_admin_user=0
  fi
  printf "%s" "$is_proxysql_admin_user"
}


# Synchronizes the users between ProxySQL and PXC
#
# This function was created to auto sync all the existing users already
# in MySQL to proxySQL's mysql_users table.  As there is not much point
# in having users in ProxySQL that don't exist in MySQL, this function
# will delete any users from ProxySQL that were not found in MySQL.
#
# Going forward you can add/remove application users in MySQL then
# rerun proxysql-admin with the --syncusers switch to replicate the changes
# to ProxySQL.
#
# LIMITATIONS: Will not work properly in cases where the same user name
#              exists in MySQL with several hosts and different passwords.
#              This will cause ProxySQL to throw a "UNIQUE constraint failed"
#              error message.
#
# Globals:
#   WRITER_HOSTGROUP_ID
#   SYNCUSERS
#
# Arguments:
#   None
#
function syncusers() {
  debug "$LINENO" "syncusers ()"

  proxysql_connection_check
  cluster_connection_check

  local mysql_version
  local password_field

  # TODO: kennt, this assumes that the original cluster node
  # (in the proxysql-admin.cnf) is up-and-running.

  # Get current MySQL users, filter out header row and mysql.sys user
  mysql_version=$(mysql_exec "$LINENO" "SELECT VERSION();" | tail -1 | cut -d'.' -f1,2 )
  check_cmd $? "$LINENO" "Could not connect to the PXC node."\
                       "\n-- Please check the PXC connection parameters and status."

  case $mysql_version in
    5.6)
      password_field="Password"
      ;;
    5.7 | 8.0)
      password_field="authentication_string"
      ;;
    10.2)
      password_field="Password"
      ;;
    10.3)
      password_field="Password"
      ;;
    *)
      error "$LINENO" "Unexpected database server version: ${mysql_version}"\
                    "\n-- This version of proxysql-admin needs to be updated."
      exit 1
      ;;
  esac
  
  mysql_users=$(mysql_exec "$LINENO" "SELECT User,${password_field} FROM mysql.user where ${password_field}!=''" "" "hide_output" |
                  grep -E -v "mysql.sys|mysql.session|mysql.infoschema" |
                  sort |
                  uniq )
  check_cmd $? "$LINENO" "Failed to load the user list from PXC."\
                       "\n-- Please check the PXC connection parameters and status."

  #Checking whether user is part of proxysql admin user list
  # Get current ProxySQL users and filter out header row
  proxysql_users=$(get_proxysql_users)

  echo -e "\nSyncing user accounts from PXC to ProxySQL"

  # TEST FOR USERS THAT EXIST IN MYSQL BUT NOT IN PROXYSQL HERE AND ADD

  # Escape all backslashes here, because the read will evaluate
  # the escaped chars
  mysql_users=${mysql_users//\\/\\\\}
  while read line; do
    if [[ -z $line ]]; then
      continue
    fi

    mysql_user=$line

    local match=0
    proxysql_users=${proxysql_users//\\/\\\\}
    while read pline; do
      if [[ -z $pline ]]; then
        continue
      fi
      if [ "$pline" == "$mysql_user" ];then
        match=1
        break
      fi
    done< <(printf "%s\n" "${proxysql_users}")

    if [[ $match -eq 0 ]]; then
      local user password
      user=$(echo "$mysql_user" | cut -f1)
      password=$(echo "$mysql_user" | cut -f2)

      # escape SQL input
      # Since we're using single quotes within the SQL statement, only need
      # to escape the single quotes for SQL
      password=${password//\'/\'\'}

      # Check if same username exists with a different password
      # delete the user to recreate.
      while read pline; do
        if [[ -z $pline ]]; then
          continue
        fi
        local puser=$(echo "$pline" | cut -f1)
        if [[ "$puser" == "$user" ]]; then
          echo "Removing existing user from ProxySQL: $user"
          proxysql_exec "$LINENO" "DELETE FROM mysql_users WHERE username='${user}' and default_hostgroup=$WRITER_HOSTGROUP_ID"
          check_cmd $? "$LINENO" "Failed to delete the user ($user) from ProxySQL database."\
                               "\n-- Please check the ProxySQL connection parameters and status."
          break
        fi
      done< <(printf "%s\n" "${proxysql_users}")

      local is_proxysql_admin_user
      is_proxysql_admin_user=$(proxysql_admin_user_check "$user")
      if [[ $is_proxysql_admin_user -eq 1 ]]; then
        echo -e "\nNote : '$user' is in proxysql admin user list, this user cannot be addded to ProxySQL"\
                "\n-- (For more info, see https://github.com/sysown/proxysql/issues/709)"
      else
        check_user=$(proxysql_exec "$LINENO" "SELECT username from mysql_users where username='${user}'")
        if [[ -z $check_user ]]; then
          echo "Adding user to ProxySQL: $user"
          proxysql_exec "$LINENO" "INSERT INTO mysql_users (username, password, active, default_hostgroup) VALUES ('${user}', '${password}', 1, $WRITER_HOSTGROUP_ID)"
          check_cmd $? "$LINENO" "Failed to add the user ($user) from PXC to ProxySQL database."\
                               "\n-- Please check the ProxySQL connection parameters and status."
        else
          echo "Cannot add the user (${user}). The user (${user}) already exists in ProxySQL database with different hostgroup."
          check_user=""
        fi
      fi
    fi
  done< <(printf "%s\n" "${mysql_users}")

  if [[ $SYNCUSERS -eq 1 ]]; then
    # TEST FOR USERS THAT EXIST IN PROXYSQL BUT NOT IN MYSQL HERE AND REMOVE
    # Again get all users
    proxysql_users=$(get_proxysql_users)

    while read pline; do
      if [[ -z $pline ]]; then
        continue
      fi
      proxysql_user=$pline

      local match=0
      while read -r line; do
        if [[ -z $line ]]; then
          continue
        fi
        if [ "$proxysql_user" == "$line" ];then
          match=1
          break
        fi
      done< <(printf "%s\n", "$mysql_users")

      if [ "$match" -eq 0 ];then
        # Delete the ProxySQL user
        local user
        user=$(echo "$proxysql_user" | cut -f1)
        echo -e "\nRemoving user from ProxySQL: $user"
        proxysql_exec "$LINENO" "DELETE FROM mysql_users WHERE username='${user}' and default_hostgroup=$WRITER_HOSTGROUP_ID"
        check_cmd $? "$LINENO" "Failed to delete the user ($user) from ProxySQL database."\
                             "\n-- Please check the ProxySQL connection parameters and status."
      fi
    done< <(printf "%s\n" "$proxysql_users")
  fi
  proxysql_load_to_runtime_save_to_disk "MYSQL USERS" $LINENO
}


# Update the cluster membership
# New members will be added to the configuration.
# By design, members that are no longer in the cluster will not be removed.
#
# Globals:
#   WRITER_HOSTGROUP_ID
#
# Parameters:
#   None
#
function update_cluster()
{
  local host_info
  local current_hosts=""
  local ip_addr port
  local cluster_host cluster_port
  local all_hostgroups
  local cluster_addresses=""

  # get the list of hostgroups given the writer-hostgroup
  all_hostgroups=$(proxysql_exec "$LINENO" \
                    "SELECT writer_hostgroup || ',' || reader_hostgroup || ',' ||
                            backup_writer_hostgroup || ',' || offline_hostgroup
                     FROM mysql_galera_hostgroups
                     WHERE writer_hostgroup = $WRITER_HOSTGROUP_ID")
  check_cmd $? "$LINENO" "Failed to retrieve the list of hostgroups from ProxySQL" \
                       "\n-- Please check the ProxySQL connection parameters and status."

  # get the list of hosts from the hosts given in the various hostgroups
  host_info=$(proxysql_exec "$LINENO" \
                "SELECT DISTINCT hostname || ':' || port,hostgroup_id,status
                 FROM mysql_servers
                 WHERE hostgroup_id in ($all_hostgroups)")
  check_cmd $? "$LINENO" "Failed to retrieve host information from ProxySQL"\
                       "\n-- Please check the ProxySQL connection parameters and status."

  host_info=$(echo "$host_info" | tr '\t' ' ')
  if [[ -n $host_info ]]; then
    # Extract the hostname and port from the rows
    # Creates a string of "host:port" separated by spaces
    while read -r line; do
      if [[ -z $line ]]; then
        continue
      fi

      local net_address
      net_address=$(echo "$line" | cut -d' ' -f1)
      net_address=$(separate_ip_port_from_address "$net_address")
      ip_addr=$(echo "$net_address" | cut -d' ' -f1)
      port=$(echo "$net_address" | cut -d' ' -f2)
      net_address=$(combine_ip_port_into_address "$ip_addr" "$port")
      current_hosts+="$net_address "
    done< <(printf "%s" "$host_info\n")

    current_hosts=${current_hosts% }
  fi

  # Iterate through the list of hosts, till we find an active host
  # (Must also check that this is a primary partition)
  for i in $current_hosts; do
    [[ -z $i ]] && continue;

    net_address=$(separate_ip_port_from_address "$i")

    local ip_addr port
    local status=""
    ip_addr=$(echo "$net_address" | cut -d' ' -f1)
    port=$(echo "$net_address" | cut -d' ' -f2)

    # This call may fail (the node may be offline)
    status=$(cluster_exec "$LINENO" "$ip_addr" "$port" \
              "SHOW STATUS LIKE 'wsrep_cluster_status';
               SHOW STATUS LIKE 'wsrep_incoming_addresses'" \
             "--skip-column-names --silent")
    [[ $? -ne 0 || -z $status ]] && continue;

    local cluster_status
    cluster_status=$(echo -en "$status" | grep "wsrep_cluster_status" | cut -f2)
    if [[ $cluster_status == "Primary" ]]; then
      cluster_addresses=$(echo -en "$status" | grep "wsrep_incoming_addresses" | cut -f2 | tr ',' ' ')
      break
    fi
  done

  if [[ -z $cluster_addresses && -z $current_hosts ]]; then
    warning "$LINENO" "update_cluster: both PXC and ProxySQL have no active nodes"
    return
  fi

  #
  # Given the WSREP members, compare to ProxySQL
  # If missing from ProxySQL, add to ProxySQL as a reader.
  #
  debug "$LINENO" "Looking for PXC nodes not in ProxySQL"

  local new_node_list=""
  for i in ${cluster_addresses}; do
    # if we have a match, the the PXC node is in ProxySQL and we can skip
    if [[ -n $current_hosts && " ${current_hosts} " =~ [[:space:]]${i}[[:space:]] ]]; then
      continue
    fi

    echo "Cluster node (${i}) does not exist in ProxySQL, adding to the writer hostgroup($WRITER_HOSTGROUP_ID)"
    net_address=$(separate_ip_port_from_address "$i")
    ip_addr=$(echo "$net_address" | cut -d' ' -f1)
    port=$(echo "$net_address" | cut -d' ' -f2)

    # Add to list of nodes to add to proxysql
    net_address=$(combine_ip_port_into_address "$ip_addr" "$port")
    new_node_list+="$net_address "
  done

  if [[ -n $new_node_list ]]; then
    add_servers_to_proxysql "$new_node_list"
    proxysql_load_to_runtime_save_to_disk "MYSQL SERVERS" $LINENO
  fi

  echo -e "\nCluster node info"
  echo "Writer hostgroup        : $WRITER_HOSTGROUP_ID"
  echo "Reader hostgroup        : $READER_HOSTGROUP_ID"
  echo "Backup writer hostgroup : $BACKUP_WRITER_HOSTGROUP_ID"
  echo "Offline hostgroup       : $OFFLINE_HOSTGROUP_ID"
  proxysql_exec "$LINENO" "SELECT hostname,hostgroup_id,port,weight FROM mysql_servers WHERE hostgroup_id in ($all_hostgroups)" "-t"

}

# Parses the script arguments and sets the global variables
#
# Globals:
#
# Arguments:
#   The arguments to the script.
#
function parse_args() {
  local go_out=""

  # TODO: kennt, what happens if we don't have a functional getopt()?
  # Check if we have a functional getopt(1)
  if ! getopt --test; then
    go_out="$(getopt --options=edv --longoptions=config-file:,proxysql-datadir:,writer-hostgroup:,backup-writer-hostgroup:,reader-hostgroup:,offline-hostgroup:,proxysql-username:,proxysql-password::,proxysql-hostname:,proxysql-port:,cluster-username:,cluster-password::,cluster-hostname:,cluster-port:,monitor-username:,monitor-password:,cluster-app-username:,cluster-app-password:,node-check-interval:,quick-demo,mode:,write-node:,use-existing-monitor-password,without-cluster-app-user,enable,disable,update-cluster,adduser,syncusers,sync-multi-cluster-users,max-connections:,max-transactions-behind:,use-ssl:,version,debug,help \
    --name="$(basename "$0")" -- "$@")"
    check_cmd $? "$LINENO" "Script error: getopt() failed with arguments: $*"
    eval set -- "$go_out"
  fi
  if [[ $go_out == " --" ]];then
    usage
    exit 1
  fi

  #
  # We iterate through the command-line options twice
  # (1) to handle options that don't need permissions (such as --help)
  # (2) to handle options that need to be done before other
  #     options, such as loading the config file
  #
  for arg
  do
    case "$arg" in
      -- ) shift; break;;
      --config-file )
        CONFIG_FILE="$2"
        check_permission -e "$LINENO" "$CONFIG_FILE" "proxysql-admin configuration file"
        debug "$LINENO"  "--config-file specified, using : $CONFIG_FILE"
        shift 2
        ;;
      --help)
        usage
        exit 0
        ;;
      -v | --version)
        echo "proxysql-admin version ${PROXYSQL_ADMIN_VERSION}"
        exit 0
        ;;
      --debug)
        DEBUG=1
        shift
        ;;
      --quick-demo )
        shift
        QUICK_DEMO=1
        ENABLE=1
        ;;
      *)
        shift
        ;;
    esac
  done

  # Reset the command line for the next invocation
  eval set -- "$go_out"

  #
  # Load the config file before reading in the command-line options
  #
  readonly CONFIG_FILE
  if [[ $QUICK_DEMO -eq 0 ]]; then
    if [ ! -e "$CONFIG_FILE" ]; then
        warning "" "Could not locate the configuration file: $CONFIG_FILE"
    else
        check_permission -r "$LINENO" "$CONFIG_FILE"
        debug "$LINENO" "Loading $CONFIG_FILE"
        source "$CONFIG_FILE"
    fi
  fi

  #
  # Iterate through the comamnd-line options
  #
  for arg
  do
    case "$arg" in
      -- ) shift; break;;
      --config-file )
        # Do no processing of config-file here, it is processed
        # before this loop (see above)
        shift 2
        ;;
      --proxysql-datadir )
        PROXYSQL_DATADIR="$2"
        shift 2
        ;;
      --proxysql-username )
        PROXYSQL_USERNAME="$2"
        shift 2
        ;;
      --proxysql-password )
        case "$2" in
          "")
            read -r -s -p  "Enter ProxySQL password:" INPUT_PASS
            if [ -z "$INPUT_PASS" ]; then
              PROXYSQL_PASSWORD=""
              printf "\nContinuing without ProxySQL password...\n";
            else
              PROXYSQL_PASSWORD="$INPUT_PASS"
            fi
            printf "\n"
            ;;
          *)
            PROXYSQL_PASSWORD="$2"
            ;;
        esac
        shift 2
        ;;
      --proxysql-hostname )
        PROXYSQL_HOSTNAME="$2"
        shift 2
        ;;
      --proxysql-port )
        PROXYSQL_PORT="$2"
        shift 2
        ;;
      --cluster-username )
        CLUSTER_USERNAME="$2"
        shift 2
        ;;
      --cluster-password )
        case "$2" in
          "")
            read -r -s -p  "Enter PXC password:" INPUT_PASS
            if [ -z "$INPUT_PASS" ]; then
              CLUSTER_PASSWORD=""
              printf "\nContinuing without PXC password...\n";
            else
              CLUSTER_PASSWORD="$INPUT_PASS"
            fi
            printf "\n"
            ;;
          *)
            CLUSTER_PASSWORD="$2"
            ;;
        esac
        shift 2
        ;;
      --cluster-hostname )
        CLUSTER_HOSTNAME="$2"
        shift 2
        ;;
      --cluster-port )
        CLUSTER_PORT="$2"
        shift 2
        ;;
      --monitor-username )
        MONITOR_USERNAME="$2"
        shift 2
        ;;
      --monitor-password )
        MONITOR_PASSWORD="$2"
        shift 2
        ;;
      --use-existing-monitor-password )
        USE_EXISTING_MONITOR_PASSWORD=1
        shift
        ;;
      --cluster-app-username )
        CLUSTER_APP_USERNAME="$2"
        shift 2
        ;;
      --cluster-app-password )
        CLUSTER_APP_PASSWORD="$2"
        shift 2
        ;;
      --without-cluster-app-user )
        shift
        WITH_CLUSTER_APP_USER=0
        ;;
      -e | --enable )
        shift
        ENABLE=1
        ;;
      --adduser )
        shift
        ADDUSER=1
        ;;
      --syncusers )
        shift
        SYNCUSERS=1
        ;;
      --sync-multi-cluster-users )
        shift
        SYNCMULTICLUSTERUSERS=1
        ;;
      -d | --disable )
        shift
        DISABLE=1
        ;;
      --update-cluster )
        shift
        UPDATE_CLUSTER=1
        ;;
      --node-check-interval )
        NODE_CHECK_INTERVAL="$2"
        shift 2
        ;;
      --mode )
        MODE="$2"
        shift 2
        ;;
      --write-node )
        WRITE_NODE="$2"
        shift 2
        ;;
      --quick-demo )
        shift
        QUICK_DEMO=1
        ENABLE=1
        ;;
      --max-connections )
        MAX_CONNECTIONS="$2"
        shift 2

        # Verify that we have an integer >= 0
        if [[ -n $MAX_CONNECTIONS ]]; then
          if ! [ "$MAX_CONNECTIONS" -eq "$MAX_CONNECTIONS" ] 2>/dev/null
          then
            error "" "option '--max-connections' requires a number : $MAX_CONNECTIONS"
            exit 1
          fi

          if [[ $MAX_CONNECTIONS -lt 0 ]]; then
            error "" "option '--max-connections' requires a number >=0 : $MAX_CONNECTIONS"
            exit 1
          fi
        else
            error "" "option '--max-connections' requires an argument"
            exit 1
        fi
        ;;
      --max-transactions-behind )
        MAX_TRANSACTIONS_BEHIND=$2
        shift 2
        ;;
      --use-ssl )
        USE_SSL="$2"
        shift 2
        ;;
      --writer-hostgroup )
        WRITER_HOSTGROUP_ID=$2
        shift 2
        ;;
      --backup-writer-hostgroup )
        BACKUP_WRITER_HOSTGROUP_ID=$2
        shift 2
        ;;
      --reader-hostgroup )
        READER_HOSTGROUP_ID=$2
        shift 2
        ;;
      --offline-hostgroup )
        OFFLINE_HOSTGROUP_ID=$2
        shift 2
        ;;
      -v | --version )
        # Detection of this setting is done before this
        shift
        ;;
      --debug )
        # Detection of this setting is done before this
        shift
        ;;
      --help )
        # Detection of this setting is done before this
        shift
        ;;
    esac
  done

  # WRITE_NODE validity check (check to see if the port is included)
  if [[ -n $WRITE_NODE ]]; then
    local ws_address
    local ws_port

    ws_address=$(separate_ip_port_from_address "$WRITE_NODE")
    ws_port=$(echo "$ws_address" | cut -d' ' -f2)

    # Check that we have a port and that it only contains digits
    if [[ -z $ws_port || ! $ws_port =~ ^[[:digit:]]*$ ]]; then
      error "$LINENO" "--write-node : expected 'address:port' found '$WRITE_NODE'"
      exit 1
    fi
  fi
  readonly WRITE_NODE


  if [[ ! $MODE =~ ^(loadbal|singlewrite)$ ]]; then
    error "" "Invalid --mode passed: '$MODE'"
    echo "Please choose one of these modes: loadbal, singlewrite"
    exit 1
  fi
  readonly NODE_CHECK_INTERVAL
  readonly MODE


  if [[ $USE_SSL != "yes" && $USE_SSL != "no" ]]; then
    error "" "Invalid --use-ssl option: '$USE_SSL'"
    echo "Please use one of these values: 'yes','no'"
    exit 1
  fi
  if [[ $USE_SSL == 'yes' ]]; then
    USE_SSL_OPTION=1
  else
    USE_SSL_OPTION=0
  fi
  readonly USE_SSL
  readonly USE_SSL_OPTION


  if [[ -z $WRITER_HOSTGROUP_ID || $WRITER_HOSTGROUP_ID -eq -1 ]]; then
    error "" "Invalid --writer-hostgroup value: '$WRITER_HOSTGROUP_ID' "
    echo "Must use a number >= 0"
    exit 1
  fi
  if [[ -z $BACKUP_WRITER_HOSTGROUP_ID || $BACKUP_WRITER_HOSTGROUP_ID -eq -1 ]]; then
    error "" "Invalid --backup-writer-hostgroup value: '$BACKUP_WRITER_HOSTGROUP_ID' "
    echo "Must use a number >= 0"
    exit 1
  fi
  if [[ -z $READER_HOSTGROUP_ID || $READER_HOSTGROUP_ID -eq -1 ]]; then
    error "" "Invalid --reader-hostgroup value: '$READER_HOSTGROUP_ID' "
    echo "Must use a number >= 0"
    exit 1
  fi
  if [[ -z $OFFLINE_HOSTGROUP_ID || $OFFLINE_HOSTGROUP_ID -eq -1 ]]; then
    error "" "Invalid --offline-hostgroup value: '$OFFLINE_HOSTGROUP_ID' "
    echo "Must use a number >= 0"
    exit 1
  fi
  readonly WRITER_HOSTGROUP_ID
  readonly READER_HOSTGROUP_ID
  readonly BACKUP_WRITER_HOSTGROUP_ID
  readonly OFFLINE_HOSTGROUP_ID


  # Check user permission to proxysql datadir
  if [[ -z $PROXYSQL_DATADIR ]]; then
    if [[ -d /var/lib/proxysql ]]; then
      PROXYSQL_DATADIR="/var/lib/proxysql"
    elif [[ -d /usr/share/proxysql ]]; then
      PROXYSQL_DATADIR="/usr/share/proxysql"
    else
      error "$LINENO" "Could not find the ProxySQL datadir.  Please specify using --proxysql-datadir"
      exit 1
    fi
  fi
  check_permission -d "$LINENO" $PROXYSQL_DATADIR "ProxySQL datadir"
  check_permission -w "$LINENO" $PROXYSQL_DATADIR
  readonly PROXYSQL_DATADIR

  debug "" "ProxySQL datadir: $PROXYSQL_DATADIR"

  if [[ $QUICK_DEMO -eq 1 ]]; then
    echo -e "\nThis script will assist with configuring ProxySQL for use with"
    echo -e "Percona XtraDB Cluster (currently only PXC in combination"
    echo -e "with ProxySQL is supported)"
    echo -e "\nYou have selected the dry test run mode.\n"

    warning "" "This will create a test user (with all privileges)"

    echo -e "in the Percona XtraDB Cluster & ProxySQL installations.\n"
    echo -e "You may want to delete this user after you complete your testing!\n"

    read -r -p "Would you like to proceed with '--quick-demo' [y/n] ? " check_param
    case $check_param in
      y|Y)
        echo -e "\nSetting up proxysql test configuration!\n"
      ;;
      n|N)
        echo -e "\nYou have selected No. Terminating.\n"
        exit 0
      ;;
      *)
        error "" "Please type [y/n]! Terminating."
        exit 1
      ;;
    esac
  fi

  if [[ ! -e $(which mysql 2> /dev/null) ]] ;then
    error "$LINENO" "The mysql client was not found, please install the mysql client package."
    exit 1
  fi

   # Check the options gathered from the command line
  if [[ $QUICK_DEMO -eq 0 ]]; then
    if [[ -z "$PROXYSQL_USERNAME" ]];then
      error "" "The ProxySQL username (--proxysql-username) is required!"
      exit 1
    fi

    if [[ -z "$PROXYSQL_HOSTNAME" ]]; then
      PROXYSQL_HOSTNAME="127.0.0.1"
    fi

    if [[ -z "$PROXYSQL_PORT" ]]; then
      PROXYSQL_PORT="6032"
    fi

    if [[ -z "$CLUSTER_USERNAME" ]];then
      error "" "The Percona XtraDB Cluster username (--cluster-username) is required!"
      exit 1
    fi

    if [[ -z "$CLUSTER_HOSTNAME" ]]; then
      CLUSTER_HOSTNAME="localhost"
    fi

    if [[ -z "$CLUSTER_PORT" ]]; then
      CLUSTER_PORT="3306"
    fi
  else
    quickdemo_get_proxysql_params
    quickdemo_get_cluster_params

    MONITOR_USERNAME='monitor'
    MONITOR_PASSWORD='monitor'
    CLUSTER_APP_USERNAME='pxc_test_user'
    CLUSTER_APP_PASSWORD=''

    readonly MONITOR_USERNAME
    readonly MONITOR_PASSWORD
    readonly CLUSTER_APP_USERNAME
    readonly CLUSTER_APP_PASSWORD
  fi

  #
  # By this point, all of the connection parameters
  # (proxysql and PXC cluster) should have been set.
  #
  readonly PROXYSQL_USERNAME
  readonly PROXYSQL_PASSWORD
  readonly PROXYSQL_PORT
  readonly PROXYSQL_HOSTNAME

  readonly CLUSTER_USERNAME
  readonly CLUSTER_PASSWORD
  readonly CLUSTER_PORT
  readonly CLUSTER_HOSTNAME

  readonly ENABLE
  readonly DISABLE
  readonly ADDUSER
  readonly SYNCUSERS
  readonly SYNCMULTICLUSTERUSERS
  readonly QUICK_DEMO
  readonly UPDATE_CLUSTER

  readonly WITH_CHECK_MONITOR_USER
  readonly WITH_CLUSTER_APP_USER

  readonly MAX_CONNECTIONS
  readonly MAX_TRANSACTIONS_BEHIND
 }

# Main function
#
# Globals:
#   ENABLE
#   DISABLE
#   ADDUSER
#   SYNCUSERS
#   SYNCMULTICLUSTERUSERS
#   QUICK_DEMO
#   UPDATE_CLUSTER
#   MODE
#   CLUSTER_APP_USERNAME
#   PROXYSQL_HOSTNAME, PROXYSQL_CLIENT_PORT
#
# Arguments:
#   None
#
function main() {

  if [[ $ENABLE -eq 1 ]]; then

    if [[ $QUICK_DEMO -eq 0 ]]; then
      echo -e "\nThis script will assist with configuring ProxySQL for use with"
      echo -e "Percona XtraDB Cluster (currently only PXC in combination"
      echo -e "with ProxySQL is supported)"
    fi
    echo -e "\nProxySQL read/write configuration mode is ${BD}$MODE${NBD}"

    enable_proxysql
    echo -e "\nProxySQL configuration completed!\n"

    PROXYSQL_CLIENT_PORT=$(proxysql_exec "$LINENO" "SELECT * FROM runtime_global_variables WHERE variable_name='mysql-interfaces'" |
                            awk '{print $2}' |
                            grep -o -P '(?<=:).*' |
                            cut -d';' -f1 )
    echo -e "ProxySQL has been successfully configured to use with Percona XtraDB Cluster\n"
    echo -e "You can use the following login credentials to connect your application through ProxySQL\n"
    if [[ $QUICK_DEMO -eq 1 ]]; then
      echo -e "${BD}mysql --user=$CLUSTER_APP_USERNAME --host=$PROXYSQL_HOSTNAME --port=$PROXYSQL_CLIENT_PORT --protocol=tcp ${NBD}\n"
    else
      echo -e "${BD}mysql --user=$CLUSTER_APP_USERNAME -p --host=$PROXYSQL_HOSTNAME --port=$PROXYSQL_CLIENT_PORT --protocol=tcp ${NBD}\n"
    fi 

    if [[ $SYNCUSERS -eq 1 ]] || [[ $SYNCMULTICLUSTERUSERS -eq 1 ]]; then
      syncusers
      echo -e "\nSynced PXC users to the ProxySQL database!"
    fi

    # Check if the incoming connection limit is smaller
    # than the backend connection limit.
    local incoming_max
    incoming_max=$(proxysql_exec "$LINENO" "select variable_value from global_variables where variable_name like 'mysql-max_connections'")
    if [[ -n $incoming_max && $incoming_max -lt $MAX_CONNECTIONS ]]; then
      warning "$LINENO" "The value of the '--max-connections' option($MAX_CONNECTIONS) exceeds"
      echo "-- the limit on incoming client connections($incoming_max). The limit on incoming"
      echo "-- connections may be increased by changing the value of 'mysql-max_connections'"
      echo "-- in the ProxySQL global_variables table."
      echo ""
    fi

  elif [[ $DISABLE -eq 1 ]]; then

    disable_proxysql
    echo "ProxySQL configuration removed!"

  elif [[ $ADDUSER -eq 1 ]]; then  

    adduser
    echo -e "\nAdded PXC application user to the ProxySQL database!"

  elif [[ $SYNCUSERS -eq 1 ]] || [[ $SYNCMULTICLUSTERUSERS -eq 1 ]]; then

    syncusers
    echo -e "\nSynced PXC users to the ProxySQL database!"

  elif [[ $UPDATE_CLUSTER -eq 1 ]]; then

    update_cluster
    echo -e "\nCluster membership updated in the ProxySQL database!"

  else

    error "" "Must specify an operation: --enable, --disable, --adduser, --quick-demo, --syncusers, or --sync-multi-cluster-users"
    exit 1

  fi
}

# Outputs the version string (major.minor) for the path passed in
#
# Globals
#   None
#
# Arguments
#   Parameter 1 : Path to the client
#
# Outputs
#   The version number (major.minor).  The version numbers are not
#   normalized, so they cannot be directly compared.
#
function get_mysql_version()
{

  local mysql_path=$1
  local version_string
  version_string=$(${mysql_path} --version)

  if echo "$version_string" | grep -qe "[[:space:]]5\.5\."; then
    echo "5.5"
  elif echo "$version_string" | grep -qe "[[:space:]]5\.6\."; then
    echo "5.6"
  elif echo "$version_string" | grep -qe "[[:space:]]5\.7\."; then
    echo "5.7"
  elif echo "$version_string" | grep -qe "[[:space:]]8\.0\."; then
    echo "8.0"
  elif echo "$version_string" | grep -qe "[[:space:]]10\.2\."; then
    echo "10.2"
  elif echo "$version_string" | grep -qe "[[:space:]]10\.3\."; then
    echo "10.3"
  else
    echo "$version_string"
    return 1
  fi
  return 0
}

#-------------------------------------------------------------------------------
#
# Step 4 : Begin script execution
#

# Internal variables
if [ -e "/dummypathnonexisting/.mylogin.cnf" ]; then
  error "" "/dummypathnonexisting/.mylogin.cnf found. This should not happen.";
  exit 1
else
  export HOME="/dummypathnonexisting"
fi

#
# Check that we can find the mysql client
#
if [[ ! -e $(which mysql 2> /dev/null) ]] ;then
  error "$LINENO" "The mysql client was not found, please install the mysql client package."
  exit 1
fi

MYSQL_CLIENT_VERSION=$(get_mysql_version "mysql")
if [[ $? -ne 0 ]]; then
  error "$LINENO" "Cannot determine the MySQL client version from the version string"
  echo "-- Version string : $MYSQL_CLIENT_VERSION"
  exit 1
fi

parse_args "$@"

# We now use the tables for configuration and thus they should reflect
# the current state before we do any modification.
proxysql_exec "$LINENO" "SAVE MYSQL SERVERS FROM RUNTIME"
proxysql_exec "$LINENO" "SAVE MYSQL QUERY RULES FROM RUNTIME"
proxysql_exec "$LINENO" "SAVE MYSQL USERS FROM RUNTIME"
proxysql_exec "$LINENO" "SAVE MYSQL VARIABLES FROM RUNTIME"

main

exit 0
